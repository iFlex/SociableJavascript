\pdfoutput=1

\documentclass{l4proj}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
%TODO: relax introduction
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = black %Colour of citations
}

\colorlet{punct}{red!60!black}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
%\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
% CSS
\lstdefinelanguage{CSS}{
  keywords={color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-}
}

% JavaScript
\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinelanguage{HTML5}{
  language=html,
  sensitive=true,	
  alsoletter={<>=-},	
  morecomment=[s]{<!-}{-->},
  tag=[s],
  otherkeywords={
  % General
  >,
  % Standard tags
	<!DOCTYPE,
  </html, <html, <head, <title, </title, <style, </style, <link, </head, <meta, />,
	% body
	</body, <body,
	% Divs
	</div, <div, </div>, 
	% Paragraphs
	</p, <p, </p>,
	% scripts
	</script, <script,
  % More tags...
  <canvas, /canvas>, <svg, <rect, <animateTransform, </rect>, </svg>, <video, <source, <iframe, </iframe>, </video>, <image, </image>, <header, </header, <article, </article
  },
  ndkeywords={
  % General
  =,
  % HTML attributes
  charset=, src=, id=, width=, height=, style=, type=, rel=, href=,
  % SVG attributes
  fill=, attributeName=, begin=, dur=, from=, to=, poster=, controls=, x=, y=, repeatCount=, xlink:href=,
  % properties
  margin:, padding:, background-image:, border:, top:, left:, position:, width:, height:, margin-top:, margin-bottom:, font-size:, line-height:,
	% CSS3 properties
  transform:, -moz-transform:, -webkit-transform:,
  animation:, -webkit-animation:,
  transition:,  transition-duration:, transition-property:, transition-timing-function:,
  }
}
\lstdefinestyle{htmlcssjs} {%
  % General design
%  backgroundcolor=\color{editorGray},
  basicstyle={\tiny},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{editorGreen}\bfseries,
  stringstyle=\color{editorOcher}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Code
  language=HTML5,
  alsolanguage=JavaScript,
  alsodigit={.:;},	
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  % German umlauts
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}
%
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\begin{document}
\title{Sociable Javascript}
\author{Milorad Liviu Felix}
\date{\today}
\maketitle
\educationalconsent
%
%NOTE: if you include the educationalconsent (above) and your project is graded an A then
%      it may be entered in the CS Hall of Fame
%
\newpage
\begin{abstract}
   As \textbf{JavaScript} has grown in popularity, it has also became more versatile. More applications running JavaScript on the same machine may result in greater memory contention among processes. To make the best use of system resources while maximising utilisation, the applications would need to be aware of each other's memory needs, and cooperate in order for them to continuously have access to the minimum running requirements. To achieve system-wide awareness at an individual application level, we propose a client-server model, where a manager process keeps track of all running client applications and controls how much memory they are allocated. We present a set of policies based on social welfare theory that model JavaScript execution environments as individuals and evaluate how they impact the execution speed and memory footprint of each application. An application with a low memory footprint, that has acceptable throughput, could make JavaScript a suitable choice for highly multiprocessing and elastic systems.
\end{abstract}
\newpage
\tableofcontents
\newpage
\chapter{Introduction}
%intro
\hspace*{3em} \textbf{JavaScript} is a highly dynamic language for web-based applications.\cite{intro}!!-!!-!!-!!%abstract. need to add anectode about how everything is modeled as an object and that is hard to interpret/exec 
 It began as a simple solution for animating web-page content, but has evolved into a \textbf{multipurpose scripting language} with growing support and popularity. A large part of the functionality of web products is now implemented in JavaScript and there are initiatives, such as NodeJS\cite{nodejs}, that aim to bring this language to the \textbf{server side}. Since the language is interpretive, browser vendors implement JavaScript \textbf{virtual machines} that perform \textbf{just-in-time} compilation to execute the code. Some of the most widely used examples are \textbf{V8} from Google Chrome\cite{v8}, Nitro from Apple Safari, Spidermonkey\cite{spidermk} from Mozilla Firefox and Chakra\cite{chakra} from Microsoft Edge.
\\\\%garbage collection
\hspace*{3em} One reason for the \textbf{considerable popularity} of the language is its \textbf{simplicity}. A key factor of this simplicity is that JavaScript programmers do not have to handle memory. This allows developers to focus on the high level functionality such as how an application responds to a certain request rather than on low level implementation details such as how much memory a new object needs and when that memory should be freed. The responsibility of memory management is passed onto the virtual machine that executes the program. While \textbf{memory allocation} may be straight forward (a new block of memory is requested from the host operating system when the application creates a new object), \textbf{freeing memory} cannot be done in the same manner, as an object that goes out of scope might still be referenced by a \textbf{live object}. The virtual machine needs to inspect the live objects and detect which ones have truly expired and free the memory they occupy. This process is called \textbf{garbage collection}.
\\\\%virtual machines optimisations
\section{Virtual Machine Optimisation}
\hspace*{3em} These \textbf{JavaScript virtual machines} are optimised to offer the best possible performance from a user perspective, this means that speed of execution and steady rendering are most important. In the case of V8, the engineers that designed it are using the term \textbf{``jank''} to refer to noticeable rendering pauses caused by JavaScript garbage collection and are currently striving to minimise it. One example of jank is when the user scrolls the page and the animation has noticeable pauses that make it look \textbf{discontinuous}. Jank occurs because in order to carry out garbage collection the execution of the JavaScript application needs to be paused. To reduce the impact observable by the user, garbage collection pauses are divided into small execution sequences and are interleaved with long execution sequences. This improves the user experience but increases the memory footprint of the application as unused memory is held for longer than necessary. Such a system is not concerned with conserving memory and cooperating with other processes in order to allow as many applications as possible to run on the system, but this behavior is justified as each tab in the browser needs to display as smoothly as possible.
\\\\%server side applications
%TODO: add some examples of nodejs services
\section{Multipurpose JavaScript}
\hspace*{3em} \textbf{JavaScript outgrew its original intended purpose} and has expanded to \textbf{server side applications} and native \textbf{client applications}. In the case of server side applications, the NodsJS framework is experiencing a growing adoption trend for services such as web-servers, push notification servers, server side voice recognition and other computation bound services. This is in part due to the fact that a large majority of the JavaScript library ecosystem is compatible with NodeJS leaving out only the libraries that utilise HTML document related methods and structures (which are not present in NodeJS). In this case, jank does not exist since no rendering is done, therefore garbage collection would only impact total execution time. Service providers would greatly benefit if these applications were to have a lower memory footprint (achieved by collecting garbage more intensely) as more processes can be run per single physical machine, thus increasing the service availability. Also being able limit memory expansion per process guarantees that system processes and other service specific administrative processes will always have enough memory to remain responsive, regardless of how loaded the client serving applications are. Elastic systems can benefit from a global service that controls memory usage of garbage collected systems as the limits can be tightened or relaxed depending on the load and total amount of memory made available at each point in time.\\%client side applications
\\\\
\hspace*{3em} JavaScript based \textbf{client side applications} are also beginning to emerge in the form of NWJS(Node Webkit JavaScript) applications. In essence this is a web browser rendering a local webpage which has access to JavaScript file system APIs and other native application functionality that is normally not included in regular web browsers for security reasons. This approach is gaining popularity especially among organisations that lack the human resources necessary to build different native applications for each platform they intend to support or want to deploy their existing web applications in the form of native applications. 
Examples of such native applications are: Powder Player - a video streaming application with torrent download and seeding integration\cite{powderplayer}, WhatsApp - a popular messenger application acquired by Facebook in 2014 \cite{whatsap}, Facebook’s messenger - Facebook's own messenger platform \cite{messenger}, DevKit - a modular integrated development environment \cite{devkit},
Wunderlist - a popular productivity application allowing users to create and share task lists\cite{wunderlist} and even a game named GameDev Tycoon\cite{tycoongame}. 
%kind of weak
Having a mechanism for controlling such an application's memory usage would allow the user to run many JavaScript applications concurrently while using an optimum amount of memory so that all the other processes can complete successfully. This way the user can play a game while listening to music and streaming files from the internet, all using JavaScript applications.
\\\\%purpose of the project
\section{Project Scope}
\hspace*{3em} The purpose of this project is to build a framework capable of \textbf{monitoring the memory usage} of every JavaScript running context and apply a memory management policy that will generate a limit for each one of them. Upon receiving its memory limit from the manager the JavaScript virtual machine will free more memory during garbage collection in order to comply.
\\\\ %motivation and social welfare
\hspace*{3em} The motivation for building such a system is improving the maximum possible \textbf{multi-programming degree}, availability and fault tolerance for services based on JavaScript applications, making this technology suitable for \textbf{multi-tasking and elastic systems}. The main benefit of enforcing a global memory utilisation policy over all of the JavaScript running contexts on a machine is reducing competition for resources and increasing cooperation. Garbage collection will be done more frequently, thus freeing up more memory and allowing more instances to run on the same machine. The end goal would be to increase the multi-programming level without hindering performance.\\
\hspace*{3em} Through the coordinated management of memory based on global information, applications achieve a form of cooperation much like individuals cooperate and responsibly share resources with each other, in order to maintain a necessary level of comfort. The key factor to the success of this framework would be to maintain acceptable throughput levels for each JavaScript appliaction. This translates directly to how long each program takes to complete. If execution time increases considerably, the applications become unfeasible. In order to find a balance between throughput and memory size, the framework models execution contexts as individuals and applies a social welfare function in order to determine how much memory each individual is allowed to use. We will attempt to build such a cooperative memory manager using concepts from \textbf{social welfare theory}.
\\\\
There are two main components to this project:
\begin{itemize}
\item The \textbf{manager} - receives memory usage information, applies the management policy and then issues limits to each execution environment.
\item a modified \textbf{JavaScript virtual machine} executes JavaScript, reports runtime context characteristics (heap size, throughput, etc) and enforces memory limits received from the manager.
\end{itemize}
The manager is a Python application and the virtual machine selected for this project is Google's V8 engine. The manager will be central to evaluating the performance of each script in relation to the applied policy using the characteristics received from the V8.

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.75\textwidth]{SimplifiedOverall.png}
    \caption{Overall project diagram.}
\end{figure}

The approach adopted was similar to the Java Forseti system developed at the University of Glasgow\cite{forseti}. To implement this system, changes need to be done to the V8 engine and a manager process that would implement the policy would need to be built. The V8 engine would need modifications that allow dynamic expanding and shrinking of a running context's (isolate) heap size and a network client that receives and executes commands issued by the manager. This can be a challenging task since the V8 project consists of \textbf{800,000+ lines of code}. %diagram

%The system would work as follows: the manager process starts a registry server that listens for connections from V8 instances. A new V8 instance would run either by itself or inside the Chrome browser and would connect to the manager process. As soon as the manager detects a new V8 instance, it starts polling it for status information (heap memory used, throughput, etc). The manager will use this information to calculate how large the heap of each isolate should be and will send the calculated value back to the V8. The engine will then try to adapt each isolate's memory consumption to match the recommended value by increasing the number of garbage collection operations.
%expand
\chapter{Background}
%java script
%garbage collection
%v8
\section{Welfare Economics}
\hspace*{3em} \textbf{Welfare economics} is a branch of economics that uses microeconomic techniques to evaluate well-being (welfare) at the aggregate (economy-wide) level.\cite{welfareeconomics} The typical evaluation begins with the derivation of a \textbf{social welfare function}. In welfare economics, a social welfare function is a function that ranks social states (alternative complete descriptions of the society) as less desirable, more desirable, or indifferent for every possible pair of social states. Inputs of the function include any variables considered to affect the economic welfare of a society.\cite{socialwelfarefunction} This is then used to rank economically feasible allocations of resources. JavaScript applications can be modeled as individuals using a a combination of the characteristics of running contexts as input values for the social welfare function. Such characteristics are heap size, available memory, throughput, etc. The exact choice of the social welfare function, selected set of runtime context characteristics and the way these characteristics are mapped to the input values of the function are what we call a \textbf{policy}. This project aims to evaluate the effectiveness of various policies in relation to different types of JavaScript applications: web pages scripts, IO bound standalone applications, computation bound standalone applications. Some policies may be better suited for standalone applications while others may work work well with web-page scripts, some might perform well overall. 
\section{JavaScript}
\hspace*{3em} In 1994, \textbf{Netscape} developed a web browser that was meant to exploit the potential of the emerging \textbf{World Wide Web}, its name was Netscape Navigator. The engineers behind the browser quickly realized that the Web needed to be more dynamic as even basic input validation had to be done by the server (requiring the browser to send the data over the network to the server and receive feedback). Later in 1995, a debate began among the engineers at Netscape about whether to add a static or scripting language to their browser. The proponents of a scripting language offered the following explanation:\cite{jsgrandpa} 
\textit{``We aimed to provide a “glue language” for the Web designers and part time programmers who were building Web content from components such as images, plugins, and Java applets. We saw Java as the “component language” used by higher-priced programmers, where the glue programmers—the Web page designers—would assemble components and automate their interactions using [a scripting language].''}
Netscape management had decided that a scripting language had to have a syntax similar to Java’s largely because of their collaboration with \textbf{Sun}, the company that created the \textbf{Java programming language}. In late November 1995, Navigator 2.0B3 came out and included the prototype, which continued its early existence without major changes. In early December 1995, Java’s momentum had grown and the language was renamed, to its final name, \textbf{JavaScript}.\cite{jsdaddy}
\\\\
\hspace*{3em} JavaScript has since grown to be one of the most popular programming languages. If popularity were to be judged by the number of projects built with JavaScript, then it has become the most popular language on GitHub\cite{github} (which in turn is one of the most popular version control services):

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.95\textwidth]{JsPop.png}
    \caption{JavaScript 1st popular language on GitHub.\cite{githut}}
\end{figure}
The popularity of a programming language comes from the size and activity of its community (the developers that build projects with the said language) and this means that JavaScript has a vast and active one. !!-!!-!!-!!
%add some sort of conclusion = JS could be good to use in backend / native side
\section{Garbage Collection}
%This chapter provides a high level overview of numerous garbage collection techniques including key defini-
%tions which shall be used throughout this report. For a fuller introduction to garbage collection techniques see
%Wilson[18] who presents a comprehensive survey paper of the basic techniques. Many of the basic memory sys-
%tem elements are shown graphically in Figure 2.1. This figure is intended to be used as a reference when reading
%this section.
\begin{figure}[!ht]
  \centering
    \includegraphics[height=15em]{Heap.png}
    \caption{Basic Memory System Diagram}
\end{figure}

\section{Why control resource allocation}
\chapter{Requirements}
\hspace*{3em} For the framework to be effective and efficient it must meet a number of criteria. !!-!!-!!-!!
\section{Non-Functional Requirements}
\begin{itemize}
\item Automatically detect new V8 processes and add them to a pool of managed processes.
\item Automatically detect when new Isolates are created by their host V8 processes and add them to a pool of active isolates.
\item Automatically detect when Isolates finish execution and remove them from the pool of active isolates.
\item Automatically detect when V8 processes finish execution, remove all isolates they host from the pool of active isolates and remove the process form the pool of managed processes.
\item Calculate limits at a set frequency for all active isolates.
\item Service a large number of V8 processes without unpredictable delays.
\item Capture every parameter of the isolate updates.
\item Plot selected status features of every isolate in the system on screen for the user to analyse as the framework is running.
\item Save the selected status features of an isolate's entire execution in a file for post-execution analysis.
\item Disable the feedback module so that the application works solely on enforcing memory limits.
\item Give access to features of the entire framework to the user.
\end{itemize}
\section{Functional Requirements}
\begin{itemize}
\item Mapping IDS
\item Given a pool of active isolates and send a status update to the correct host V8 process
\item Given a list of isolates and a maximum available memory value and output a list of memory limits for each isolate
\item Given a collection of status values for an isolate, plot the selected (relevant) ones on screen in the window corresponding to the isolate.
\item Given a collection of status values for an isolate, append them to a file containing the full history for that isolate.
\item 
\end{itemize}
\newpage
\chapter{Design}
\section{Overview}

The overall framework has two main components:
\begin{itemize}
\item A \textbf{manager} - keeps track of active V8 instances, polls V8 instances for status information periodically, groups and plots the status information, calculates the memory allowance for each V8 Isolate, sends the appropriate commands containing the memory limits.
\item A \textbf{modified V8 engine} - connects to manager, retrieves status information and responds to poll requests and commands, depending on current memory limit: intensifies or relaxes garbage collection process.
\end{itemize}

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.85\textwidth]{OverallFramework.png}
	\caption{Overall project diagram detailed.}
\end{figure}
\hspace*{3em} In distributed systems a high per node multi-programming degree translates to high availability. This kind of environment also has potential to behave in an elastic way, making more resources available when the load increases and reducing the utilised resources when it diminishes. This means that our framework would have a greater impact when applied to a cluster of computers running JavaScript applications rather than a single computer.\\
\hspace*{3em} In order to adapt to this scenario the interaction between the V8 instances and the manager is done through the network, using TCP/IP. This allows the manager process to reside on any machine in a network and coordinate the memory usage of all the V8 instances running within the cluster. This makes the framework very adaptable to various use scenarios. For example: if the frameworks is to be used on a single computer it becomes a special case of the general model, a cluster with one node.
\\\\
\hspace*{3em} A \textbf{JSON} protocol is used to represent the commands and updates that are exchanged by the V8 instances and manager process. JSON is a good format option as it allows easy extension of the protocol schema, by simply adding additional keys the the concerned entities.
\begin{lstlisting}[language=json,firstnumber=1]
{
  "global":{"action":"","error":"", ... },
  "TotalIsolates":Integer,
  "isolates":{
    "1":{ "action":"","error":"", "heap":Integer,"throughput":Float,... },
    "2":{...}
    ...
  }
}
\end{lstlisting}
Here are the possible values that the \textbf{action} fields can have:\\\\
\begin{tabular}{  l  l  l  l  }
  Action & Global & Per Isolate & Description \\
\hline
  status & Yes & Yes & Isolate status request packet\\
  update & Yes & Yes & Isolate update response packet\\
  set\_heap\_size & No & Yes & Sets the heap size threshold over which the GC should intensify\\
  set\_max\_heap\_size & No & Yes & Sets the absolute maximum size the isolate can have\\
  terminated & Yes & Yes & V8 notifies the manager that one of its isolates has finished execution\\
\hline
\end{tabular}
\section{V8}
\hspace*{3em} The V8 virtual machine is based on isolated execution environments, each application runs in an isolated environment without the possibility of accessing resources owned by other applications running within the same V8 process. These isolation environments are called \textbf{isolates}. In essence, each isolate is an instance of the V8 virtual machine, having its own \textbf{heap space}, \textbf{garbage collector} and \textbf{compiler}. Only one thread can access an isolate at a time in order for the isolation to be maintained. 

\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.85\textwidth]{V8Internals.png}
	\caption{V8 Internal Architecture.}
\end{figure}

A \textbf{context} defines a script execution environment by defining an object in an isolate's heap as a global object. Therefore, many contexts can exist in a given isolate and can also share any of their objects easily.
\begin{lstlisting}[style=htmlcssjs]
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script type="text/javascript" src="http://www.gla.ac.uk/1t4/generic/scripts/libs/jquery/jquery-1.7.2.min.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/1t4/generic/scripts/libs/jquery/jquery-ui.min.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/0t4/generic/video/new/jwplayer/jwplayer.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/0t4/generic/scripts/bbq/jquery.ba-bbq.min.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/0t4/generic/scripts/raccoon.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/1t4/generic/scripts/jquery.flexslider.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/1t4/generic/scripts/main.js"></script>
        <script type="text/javascript" src="http://www.gla.ac.uk/1t4/generic/scripts/video.js"></script>
\end{lstlisting}
In the above extract from the HTML source of Glasgow University's website, each HTML script tag will cause the V8 to create a new context. Every script will be loaded in a different context but will share global variables.\\\\
The \textbf{heap} is divided into a set of spaces:
\begin{itemize}
\item \textbf{New Space} - Most objects are allocated here. This space is small and is designed to be garbage collected very quickly, independent of other spaces. 
\item \textbf{Old Space} - holds most objects that have pointers to other objects or contain raw data. Objects that survive the new space for a certain amount of time are moved here.  
\item \textbf{Code Space} - contains the instructions that comprise the compiled scripts
\item \textbf{Map Space} - Cells, Cell Properties and Maps !!-!!-!!-!!
\item \textbf{Large Object Space} - contains objects that are larger than the size limits of the other spaces. These objects are never moved by the garbage collector.
\end{itemize}
Each space is divided into a set of pages. A Page is a contiguous chunk of memory, allocated using operating system calls. Pages are always 1 MB in size and 1 MB aligned, except in large-object-space, where they may be larger. In addition to storing objects, pages also contain a header (with various flags and meta-data) and a marking bitmap (used to indicate which objects are live). Each page also has a slots buffer, allocated in separate memory, which forms a list of objects which may point to objects stored on the page.\cite{v8gctour}
\\\\
\textbf{Garbage collection} is comprised of two algorithms:
\begin{itemize}
\item \textbf{Scavenger} - is a copying garbage collection based on Cheney's algorithm. It only operates on the new space and occurs frequently.
\item \textbf{Mark Compact} - operates on the every other space except new space. It does not perform compaction on the large object space.
\end{itemize}

New-space is divided into two equal sized semi-spaces: to-space and from-space. Most allocations are made in to-space (with the exception of certain kinds of objects, such as executable Codes which are always allocated in old-space). When to-space becomes full, to-space and from-space are swapped. Then the live objects are copied out of the from-space either back into to-space or to old-space. Copying the objects into to-space also has the effect of compacting the space which improves locality of reference which, in turn, improves performance.%!
\\\\
Mark-Sweep \& Compact !!-!!-!!-!!
\\\\
\hspace*{3em} The garbage collection process incurs a certain performance cost. While actual memory \textbf{deallocation} can be done in \textbf{parallel} with the execution of JavaScript, the marking, moving and copying of live objects is much harder to parallelise. This is why garbage collection suspends the execution of hosted application. Since the new space is small, the frequent invocation of the Scavenger does greatly impact performance. The Mark-Compact on the other hand requires considerable pauses. To mitigate this, incremental marking has been implemented as well as a form of a deadline for each garbage collection pause. This way, the large pauses are divided into smaller ones causing unused memory to remain allocated for a longer period but improving the user perceived execution delay.

\subsection{Modifications}
\hspace*{3em} For the purpose of this project, the V8 engine had to be modified in order to communicate and comply with the manager process. This required both changes to existing code and additions of new code. Below is an overall diagram of the changes and additions:\\
\begin{figure}[!ht]
  \centering
    \includegraphics[width=0.85\textwidth]{V8Modifications.png}
	\caption{V8 modifications.}
\end{figure}\\
\begin{itemize}
\item \textbf{Heap} modifications allow setting a heap size limit and retrieving information about the memory usage (used memory, available memory and old space size). If the total heap size is larger than the set limit, the garbage collector will try to free as much memory needed to comply with it. Otherwise, when the heap size nears the set limit, garbage collection work intensifies to make sure it stays below the limit.
\item \textbf{Isolate} modification keep track of all the active isolates within the V8 process, measure execution and garbage collection times and calculate per isolate \textbf{throughput}. When a new isolate is crated, the tracker assigns it an numeric ID and adds it to a list of active isolates. When it finishes execution, its assigned ID is marked as free and the isolate is removed from the list.
\item A \textbf{Networking} client execution thread has been added to the V8 process for it to communicate with the manager. It is responsible with connecting to the manager, dividing the network data stream received from the manager into request packets, decoding them and performing the required actions and sending a response to the manager.
\item \textbf{Encoding} is nested, the first form is JSON which gets encoded to Base64. The latter uses a restricted set of characters to represent the payload which allows separating packets using ASCII characters that are not part of Base64. This allows the JSON payload to contain any symbols in its fields (even the packet separator character) without altering packet boundaries which simplifies the decoding process.
\item \textbf{Configuration} is done through a text file placed in the same folder as the V8 binary. This is meant to make the modified V8 more adaptable to other projects such as NodeJS and Chrome. If command line arguments were used in stead, they would have to be mirrored in both NodeJS and Chrome. The configuration file contains the IP address and port of the manager machine.
\end{itemize}
\section{Manager}
% High level description of the manager
\hspace*{3em} The main function of the \textbf{manager process} is to control the \textbf{memory limits} of each isolate. To do this, it needs to keep \textbf{track} of \textbf{active isolates}, \textbf{poll for status updates}, calculate new memory limits for every isolate and \textbf{give feedback} to the user on the status of the system. These functions have been divided into three main components: \textbf{Tracking}, \textbf{Management} and \textbf{Plotting}. The figure below is intended to be used as a reference when reading the remainder of this chapter.
\\!!-!
\begin{figure}[!ht]
  \centering
    \includegraphics[width=1.0\textwidth]{PythonManager.png}
	\caption{Manager architecture.}
\end{figure}
\subsection{Tracking}
\hspace*{3em} This module is responsible with interacting and keeping track of the active isolates through the coordinated use of its components: \textbf{Registry Server}, \textbf{Communicator} and \textbf{Registry}. From the point of view of the framework, this module offers a means of communication with active isolates.
\\\\ %DESIGN_DECISION
\hspace*{3em} The registry maintains a \textbf{representation of the environment} managed by the application. Isolates are grouped together based on the V8 process they belong to and the machine they run on. The listing below shows the structure of the registry:
\begin{lstlisting}[language=json,firstnumber=1]
[{
  "id":"127.0.0.1",
  "v8s":[
  	{"id":1,"isolates":[
  		{"id":1,"heap":40542,"throughput":1.5},
  		{"id":2,"heap":150241,"throughput":15.5},
		...]
	},
  	{"id":2,"isolates":[
		{"id":1,"heap":20541,"throughput":0.56},
        {"id":1,"heap":120443,"throughput":5.21},
		...]
	},
	...]
}, ... ]
\end{lstlisting}
In the case portrayed above, there are two V8 processes running on a the same machine as the manager process, each having two isolates. Using a hierarchical storage structure has the advantages of \textbf{minimal data redundancy}, ease of \textbf{extensibility} and \textbf{high topology fidelity}. The memory limits produced by the manager must not exceed the available memory of each machine, this requires knowing the provenience of each isolate. Each isolate is associated a local ID by its host V8, this is used to send memory limitations and other commands to the correct isolates. In order to send the commands to the right receiver, the active communications channel for each V8 process needs to be stored as well. If a non hierarchical structure such as a list were to be used, the aforementioned aspects would be more difficult to manage: the communication channel would be stored inside each isolate record adding one redundant field (many isolates can have the same host V8 process), mapping isolates to their host V8 processes and to their host machines would add even more redundant fields, determining which isolates belong to the same machine would become less efficient as it would require iterating through the entire list and mapping isolate updates coming from the network to their respective list records would require using a composite key in order to avoid iterating through the list. !!-!
\\\\
\hspace*{3em} The communicator represents an open channel to one V8 process. It handles encoding, decoding, sending and receiving messages to/from the V8. A communicator can represent at most one V8 instance at any given time.\\
\hspace*{3em} The Registry Server is responsible for servicing new connections from V8 instances to the manager. Once a new V8 engine connects to the manager, a record is added to the registry. A new communicator is created for the V8 and is added to its registry record. When a V8 finishes execution (or terminates abnormally), its communicator detects the closing of the channel and removes the corresponding V8 record from the registry. Since the communicator is stored in the V8 registry record, this will cause the communicator to cease to exist. 
\subsection{Management}
\hspace*{3em} The management module is responsible for \textbf{controlling the active isolates} by polling for updates, running a policy program that calculates memory limits, sending the calculated limits to the corresponding V8 processes and providing control over the framework to the user. The constituent components of this module are: the \textbf{Policy Executor}, \textbf{Policy Scripts} and a \textbf{Command Line Interface}.
\\\\
\hspace*{3em} The \textbf{Policy Scripts} are a collection of scripts that can be \textbf{loaded} into the manager framework \textbf{at run-time}. Only one such script can be running at any give time. A policy script receives a list of isolates and a maximum memory amount as input and \textbf{outputs the memory limits} for each of the provided isolates. All of the isolates in the input list run on the same machine, the maximum memory amount represents the maximum quantity of memory that JavaScript applications can use on the machine in question. This limitation reflects the fact that isolates running on one machine can not be allocated memory from multiple machines, therefore the total memory granted to the isolates can not be larger than the amount of physical memory available to the host machine !!-??-!!. It follows from this that the policy script needs to be run once for each machine managed by the framework. 
\\\\
\hspace*{3em} The \textbf{Policy Executor} regularly \textbf{polls} every V8 process present in the registry for status updates. These updates contain information such as: \textbf{in use heap size}, \textbf{total heap size}, available memory and \textbf{throughput}, which gets \textbf{copied into} the corresponding isolate record from  \textbf{the registry}. This information is used by the policy script to decide how much memory an isolate should have. The executor then groups all of the isolates based on their host machine and runs the current policy script for each machine.
\\\\
\hspace*{3em} The \textbf{command line interface} provides user access to the manager's functionality. Supported operations include changing the used policy script, changing the frequency of the status update polls, getting the latest status information of managed isolates, setting an isolate's memory limit, etc. This component is central to the evaluation as it allows the framework to test multiple policies without the overhead of restarting the whole infrastructure for every test, faulty policies can be detected during execution and swapped with correct ones, the full history of the status updates can be stored in files and examined post-execution or it can be plotted in real time on screen.
\\\\
\hspace*{3em} These three components come together to form the core of the framework by generating the memory limits for each manged isolate and allowing the user, the ultimate judge of the framework's effectiveness, to be part for the process and to observe its results in real-time. 
\subsection{Plotting}
\hspace*{3em} \textbf{Feedback} is crucial to evaluating the effectiveness of the policy used and, in turn, of the whole framework. This is why the manager application has a component dedicated to \textbf{gathering every status update} received by the registry and plotting a selected set of values on screen. Each full screen of plot history is saved in a PNG file, while the full history of the isolate's selected status values is saved to a CSV file for post-execution analysis. This module is comprised of three components: \textbf{Plotter}, \textbf{Plot Server}, \textbf{Plotting Service}.
\\\\
\hspace*{3em}  The \textbf{plotter} has the sole responsibility of receiving plot data, drawing it on screen and saving it to a file. It is modeled as a separate process from the manager framework. Plotters are started on demand, depending on how many isolates are being managed, each one represents a single isolate. 
\\\\
\hspace*{3em}  The \textbf{plotting service} is responsible with mapping a plot stream to one plotter process. A plot stream is comprised of the stream of status updates concerning one particular isolate. This service is responsible with detecting new streams, starting plotter processes for them and sending the plot data to the correct plotter processes. When a stream ends, because there is considerable overhead for creating a new process (and a new graphical window for drawing the plot), the plotting service keeps its corresponding plotter process in an idle state until a new stream is detected.
\\\\
\hspace*{3em} The \textbf{plotting server} has a function very similar to the registry server discussed in section 4.3.1. It starts plotter processes, when requested by the plotting service, and waits for them to connect in order to mark them as idle(ready to plot). The plotter processes are kept in a stack until they are needed by the plotting service. When a stream ends, the plotting service returns the plotter process to the server's stack in order to wait for a new stream to start.
\\\\
\hspace*{3em} The approach of having multiple separate processes handling plotting was chosen over having one process updating multiple windows (or multiple subplots) mainly because the library used is not designed to manage multiple independent plot windows but also to increase flexibility. With this model some plots (or all of them) could be offloaded to a different machine. !!-??  
\section{Software Engineering}
Separation of concerns\\
Extensibility - properties can be added and removed\\
Modularisation in Folders with closely related code\\
Plugability of policy - loose coupling\\
!!-!!-!!-!!
\newpage
\chapter{Implementation}
\section{Overview}
Protocol implementation
JSON library
\section{V8 Client}
\section{Manager}
\section{Testing}
Add testing bit
\\\\
\hspace*{3em} After modular testing was completed the final step was to ensure that the manager framework worked as a whole and did indeed affect the amount of memory an isolate could utilise. The graph below shows the evolution of the heap size of an isolate controlled with the manager framework:
\begin{figure}[!ht]
  \centering
    \includegraphics[width=1.0\textwidth]{ControlWorks.png}
	\caption{Controlling heap size.}
\end{figure}

\chapter{Evaluation}
\subsection{Inverse Throughput Policy}
\begin{displaymath}
Total Throughput = \sum_{i=0}^{N} 101 - t_i
\end{displaymath}
\begin{displaymath}
Hard Heap Limit_i = MaximumMemoryPerMachine \times \frac{101 - t_i}{Total Throughput}
\end{displaymath}
\section{Robin Hood Policy}
Definitions: Isolate(h,a,t,L) h is the used heap memory, a is the unused heap memory, L is the maximum allowed heap size, t is the throughput. N is the total number of isolates running on a machine, P is the number of poor isolates, R is the number of rich isolates. 
\begin{displaymath}
Immediate Budget = Total Allowed Memory - \sum_{i=0}^{N}L_i
\end{displaymath}
\begin{displaymath}
Need_i     = Max(0,h_i \frac{-\log_2{t_i}}{2} - L_i)
\end{displaymath}
\begin{displaymath}
Total Need = \sum_{i=0}^{P}Need_i
\end{displaymath}
\begin{displaymath}
OverflowNeed     = Max(0,TotalNeed - ImmediateBudget) 
\end{displaymath}
\begin{displaymath}
AllocatableNeed     = Max(0,TotalNeed - OverflowNeed) 
\end{displaymath}
\begin{displaymath}
StealAllowance = Min(0.5,\frac{OverflowNeed}{\sum_{i=0}^{R}L_i}) 
\end{displaymath}
\begin{displaymath}
AllocateAllowance = \frac{AllocatableNeed}{TotalNeed} \times Min(1.0,\frac{AllocatableNeed}{ImmediateBudget}) 
\end{displaymath}
\begin{displaymath}
GiveAllowance = \frac{OverflowNeed}{TotalNeed} \times Min(1.0,\frac{OverflowNeed}{TotalStolen}) 
\end{displaymath}
\begin{displaymath}
Steal_i = StealAllowance \times L_i 
\end{displaymath}
\begin{displaymath}
Give_i = (GiveAllowance + AllocateAllowance) \times Need_i 
\end{displaymath}

\section{Policy 2}
\section{Policy 3}
\chapter{Conclusion}
\section{Future Work}
Test
%more accurate biblio
\begin{thebibliography}{9}
\bibitem{intro}
Gregor Richards, Andreas Gal, Brendan Eich, Jan Vitek,
\emph{Automated Construction of JavaScript Benchmarks},
\bibitem{v8gctour}
A tour of the V8 garbage collector,
\url{http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection},
\bibitem{nodejs}
NWJS Project
\url{http://nwjs.io/}
\bibitem{nwjs}
NodeJS Project
\url{https://nodejs.org/en/}
\bibitem{v8}
V8 Engine
\url{https://developers.google.com/v8/}
\bibitem{spidermk}
SpidermonkeyEngine
\url{https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey}
\bibitem{chakra}
Chackra Engine
\url{https://github.com/Microsoft/ChakraCore}
\bibitem{forseti}
Callum Cameron, Jeremy Singer, David Vengerov
\emph{The Judgment of Forseti: Economic Utility for Dynamic Heap Sizing of Multiple Runtimes},
\bibitem{powderplayer}
\url{https://github.com/jaruba/PowderPlayer}
\bibitem{whatsap}
\url{https://web.whatsapp.com/}
\bibitem{messenger}
\url{http://messengerfordesktop.com/}
\bibitem{devkit}
\url{https://github.com/printhom/devkit-core}
\bibitem{wunderlist}
\url{https://www.wunderlist.com/download/}
\bibitem{tycoongame}
\url{http://www.greenheartgames.com/app/game-dev-tycoon/}
\bibitem{welfareeconomics}
Deardorff, Alan V. (2014), "Welfare economics", Deardorffs' Glossary of International Economics \url{http://www-personal.umich.edu/~alandear/glossary/w.html#WelfareEconomics}
\bibitem{socialwelfarefunction}
Amartya K. Sen, 1970 [1984], Collective Choice and Social Welfare, ch. 3, "Collective Rationality." p. 33, and ch. 3*, "Social Welfare Functions." \url{http://www.citeulike.org/user/rlai/article/681900}
\bibitem{jsgrandpa}
Naomi Hamilton, “The A–Z of Programming Languages: JavaScript,” Computerworld, July 30, 2008, \url{http://bit.ly/1lKldIe}
\bibitem{jsdaddy}
 Paul Krill, “JavaScript Creator Ponders Past, Future,” InfoWorld, June 23, 2008, http://bit.ly/1lKlpXO; Brendan Eich, “A Brief History of JavaScript,” July 21, 2010, \url{http://bit.ly/1lKkI0M}
\bibitem{github}
GitHub, version control service based on git \hspace*{1em} \url{https://github.com/}
\bibitem{githut}
GitHut, Statistics for GitHub \hspace*{1em} \url{http://githut.info/}
\bibitem{gcpaper}
Paul R Wilson. Uniprocessor garbage collection techniques. In Memory Management, pages 1–42.
Springer, 1992.
\end{thebibliography}
\end{document}
