Ind. Proj.
-------------------------------------------------------------------------------
DONE >> GCPrologue callback function in Isolate code
DONE >> GCEpilogue callback function in Isolate code
DONE >> Simple printout to STDOUT to check hooks fire
-------------------------------------------------------------------------------
DONE >> ExecTime vector add to Isolate
DONE >> GCTime   vector add to Isolate
DONE >> StoreIndex for above vectors add to Isolate
DONE >> GCPrologue & GCEpilogue time measure
DONE >> Store time measurements in ExecTime and GCTime
-------------------------------------------------------------------------------
DONE >> Commit measurements to file for preliminary plotting
-------------------------------------------------------------------------------
DONE >> Generate Plots for multiple benchmarks and decide how to calculate overall
GC & EXEC time - !! only binarytree and benchmark trigger garbage collection, need larger benchmarks
-------------------------------------------------------------------------------
DONE >> getHeapSize() - gets current heap size
DONE >> getThroughput() - gets current throughput
DONE >> setHeapSizeTarget() - sets the target heap size to which the system should try to scale
DONE_FAILED >> adjustHeapSize() - brings the heap size closer to the target heap size ( carefully segmented so that performance is not impacted )

| USELESS - ABORTED 
|V8 JSON class:
|DONE >> decode
|DONE >> encode
|DONE >>	getNumber
|DONE >>	getString
|DONE >>	getValue
|DONE >>	setNumber
|DONE >>	setString
|DONE >>	setValue
|DONE_NOT_WORKING >>	Integrate Locker for safe execution
|Use a separate fresh context so that running scripts are not impacted
|taking away execution time from an Isolate - not good
| * using jsoncpp embedded in v8  >>

DONE >> Implement protocol change to accommodate the limitations of v8JSON
DONE >> Integrate v8JSON in Protocol
DONE >> Integrate v8JSON & Protocol in build process

DONE >> Store a list of active isolates using STL Maps
DONE >> onCreation - addToList
DONE >> onTeardown - removeFromList
DONE >> Integrate v8JSON and Protocol in Overlord
DONE >> Implement protocol actions in overlord << DO_TEST

DONE >> Build Python Monitor program << DO_TEST
-------------------------------------------------------------------------------
IN_PROG >> Do more plots and test that restrictions are being obeyed
DONE >> Add base64 encoding/decoding
DONE >> make overlord aware of separated base64 streams + smart TCP flushing using padding
DONE >> Test connectivity between Monitor and Overlord
Ensure packetisation is implemented correctly in both monitor and overlord in order to make sure each request gets isolated and handled

* Integrate in Chromium
* Implement memory management policy

!! fix the terminate isolate method so that it does not cause a seg fault. This is because .Dispose simply calls the destructor
try using Isolate.exit();

!! find out about threading and how to run concurrent code on same isolate - Locker, Unlocker proper setup
at the moment the thread that loads the script is the one that executes it. So the script blocks the thread untill it finishes
!! find a way to make it asynch
!! read more about GC & mem management
-------------------------------------------------------------------------------
++ Write dissertation introduction chapter + skeleton
-------------------------------------------------------------------------------

Maximum expansion - controlled through maximum old_space size

Heap Size Control:
Freeing from FreeList - trying to find full empty pages in the free lists and release the memory
is not very effective as most scripts fragment the memory and full free pages are never encountered
(tried finding pages in the old_space and map_space, large object space was ignored)

DONE >> Modify Mark-Compact to free immediately after compaction
looks like the MarkCompact attempt to return as much memory as possible to the OS
throug the use of evacuation_candidates. By forcing more garbage collection the 
lasy sweeper is forced to simply do more work and free more memory. 

-> prerun script to find mimimum heap and then run with min heap. Impractical because realtime code is influenced by nondeterministic external events.

Make GC less lazy if targetHeapSize < heapSize 
!!!! ---------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
DISCOVERY: Setting the maximum heap size lowers the actual used memory if it is over the set threshold :D
this saves me work :D yey

DISCOVERY: can force the mark-compact to be less lazy by manipulating the output of heap::shouldReduceMemory

* the used memory fluctuates upon each GC
* Find more benchmarks

---------------------------------COURSEWORK------------------------------------
CA4 ---------------------------------------------------------------------------
11 More Lectures to revise

AI4 ---------------------------------------------------------------------------
All Required Book Chapters + Exercises
-------------------------------------------------------------------------------

Week 1 ( 16 - 20 Dec)

Week 2 ( 21 - 27 Dec)

Week 3 ( 28 - 3 Ian )

Week 4 ( 4 - 10 Ian )
